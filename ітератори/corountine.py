# А теперь о том, ради чего это, собственно, затевалось.
# Оказывается, генератор может не только возвращать значения, но и принимать их на вход.

# Напишем простую реализацию генератора, который может складывать два аргумента,
# хранить историю результатов и выводить историю.
# Давайте теперь избавим себя от необходимости каждый раз руками инициализировать генератор.
# Решим это типичным, для питона, образом, с помощью декоратора.

def coroutine(f):
    def wrap(*args, **kwargs):
        gen = f(*args, **kwargs)
        gen.send(None)
        return gen

    return wrap


@coroutine
def calc():
    history = []
    while True:
        x, y = (yield)
        if x == 'h':
            print(history)
            continue
        result = x + y
        print(result)
        history.append(result)


c = calc()

print(type(c))  # <type 'generator'>

# c.next() # Необходимая инициация(если без сопрограмы). Можно написать c.send(None)
c.send((1, 2))  # Выведет 3
c.send((100, 30))  # Выведет 130
c.send((666, 0))  # Выведет 666
c.send(('h', 0))  # Выведет [3, 130, 666]
c.close()  # Закрывем генератор
